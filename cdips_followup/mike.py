#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from __future__ import annotations

import re
from typing import Dict, Iterable, List, Mapping, Tuple

import numpy as np
from astropy.io import fits


def _concat_wat_strings(
    header: Mapping[str, str],
    prefixes: Iterable[str] = ("WAT2_",),
) -> str:
    """Concatenate IRAF multispec WAT* cards into a single raw string.

    NOTE: Concatenate with NO added separators. WAT values can split
    numeric literals across cards; inserting spaces would corrupt them.

    Generated by GPT-5 Thinking on October 15 2025.

    Args:
        header: FITS header mapping (e.g., `hdu.header`).
        prefixes: Header key prefixes to include (usually just "WAT2_").

    Returns:
        The concatenated WAT string.
    """
    parts: list[Tuple[int, str]] = []

    for prefix in prefixes:
        for key in header:
            if key.startswith(prefix):
                try:
                    idx = int(key.split("_")[1])
                except Exception:
                    continue
                parts.append((idx, header[key]))

    parts.sort(key=lambda t: t[0])
    return "".join(v for _, v in parts)


def _parse_spec_blocks(wat: str) -> Dict[int, str]:
    """Extract `specN = "..."` blocks from a WAT string.

    Generated by GPT-5 Thinking on October 15 2025.

    Args:
        wat: Concatenated WAT string.

    Returns:
        Mapping from spec index (int) to the quoted spec payload (str).
    """
    pat = re.compile(r'spec(\d+)\s*=\s*"([^"]+)"')
    out: Dict[int, str] = {}
    for m in pat.finditer(wat):
        idx = int(m.group(1))
        payload = m.group(2).strip()
        out[idx] = payload
    return out


def _coerce_fields_from_tokens(tokens: List[str]) -> List[str]:
    """Coerce a possibly split token list into 9 well-formed fields.

    Expected strict field formats:
      0) two digits                     -> r'^\\d{2}$'
      1) literal 1                      -> r'^1$'
      2) literal 0                      -> r'^0$'
      3) 4 digits '.' 12 digits         -> r'^\\d{4}\\.\\d{12}$'
      4) '0.' + 17 digits               -> r'^0\\.\\d{17}$'
      5) four-digit int                 -> r'^\\d{4}$'
      6) literal 0.000000               -> r'^0\\.000000$'
      7) float with 6 decimals          -> r'^\\d+\\.\\d{6}$'
      8) float with 6 decimals          -> r'^\\d+\\.\\d{6}$'

    Tokens may be split (e.g., "6768", ".960540189786"); this routine
    concatenates adjacent tokens until the current field regex matches.

    Generated by GPT-5 Thinking on October 15 2025.

    Args:
        tokens: List of whitespace-split tokens from a payload.

    Returns:
        List of 9 string fields matching the formats above.

    Raises:
        ValueError: If fields cannot be reconstructed.
    """
    print(tokens)

    pats = [
        re.compile(r"^\d{2,3}$"),
        re.compile(r"^1$"),
        re.compile(r"^0$"),
        re.compile(r"^\d{4}\.\d{10,13}$"),
        #re.compile(r"^0\.\d{17}$"),
        re.compile(r'^0\.\d{15,18}$'),  # 0. followed by 15, 16, 17, or 18 digits
        re.compile(r"^4096$"),
        re.compile(r"^0\.000000$"),
        re.compile(r"^\d+\.\d{6}$"),
        re.compile(r"^\d+\.\d{6}$"),
    ]

    fields: List[str] = []
    i = 0
    for fi, pat in enumerate(pats):
        if i >= len(tokens):
            raise ValueError("Ran out of tokens while parsing multispec.")

        cur = tokens[i]
        i += 1
        # Concatenate subsequent tokens until the pattern matches.
        while not pat.match(cur):
            if i >= len(tokens):
                raise ValueError(
                    f"Cannot form field {fi} with value {cur!r}."
                )
            cur += tokens[i]
            i += 1
        fields.append(cur)

        print(fields)

    # If there are leftover tokens, that's an error (malformed payload).
    if i != len(tokens):
        extra = " ".join(tokens[i:])
        raise ValueError(f"Extra tokens at end of payload: {extra!r}")

    return fields


def _payload_fields(payload: str) -> List[str]:
    """Split payload and coerce to 9 strict-format multispec fields.

    Generated by GPT-5 Thinking on October 15 2025.

    Args:
        payload: The content inside a `specN = "..."` block.

    Returns:
        A list of 9 fields as strings.
    """

    ##########################################
    ##########################################
    # NOTE: this substitution insanity is trying to tease out the myriad ways
    # in which the wavelength solutions written to the headers can be
    # malformed.  cooking up the right regexes is the game.

    # examples and generalization with simple capture
    payload = re.sub(r'(?m)^701 0', '70 1 0', payload)
    payload = re.sub(r'(?m)^811 0', '81 1 0', payload)
    payload = re.sub(r'(?m)^(\d{2})1 0', r'\1 1 0', payload)
    # example and generalization
    payload = re.sub(r'(?m)^67 1 0(\d)', r'67 1 0 \1', payload)
    payload = re.sub(r'(?m)^(?P<first>\d{2,3}) 1 0(?P<digit>\d)',
                     r'\g<first> 1 0 \g<digit>', payload)
    # examples and generalization
    payload = re.sub(r'(?m)^53 10', '53 1 0', payload)
    payload = re.sub(r'(?m)^67 10', '67 1 0', payload)
    payload = re.sub(r'(?m)^(?P<first>\d{2,3}) 10 ',
                     r'\g<first> 1 0 ', payload)
    # single case
    payload = re.sub(r'40960.000000', '4096 0.000000', payload)
    # merge aginst 4096 col requiring at least 10 leading digits
    payload = re.sub(r'0\.(\d{10,})4096', r'0.\1 4096', payload)
    # 0.00000 merge on trailing
    payload = re.sub(r'0\.000000(\d+\.\d+)', r'0.000000 \1', payload)
    # examples and generalization
    payload = re.sub(r'165.145000171.165000', r'165.145000 171.165000', payload)
    payload = re.sub(r'45.88100051.981000', r'45.881000 51.981000', payload)
    payload = re.sub(r'625.968000631.548000', r'625.968000 631.548000', payload)
    payload = re.sub(r'705.248000712.048000', r'705.248000 712.048000', payload)
    payload = re.sub(r'(\d+\.\d{3}000)(\d+\.\d{3}000)', r'\1 \2', payload)
    # examples and generalization
    payload = re.sub(r'5125.7401614695380.03667289001350582',
                     r'5125.740161469538 0.03667289001350582', payload)
    payload = re.sub(r'4902.2362680530290.03510779602947878',
                     r'4902.236268053029 0.03510779602947878', payload)
    payload = re.sub(r'(\d{4,}\.\d+)(0\.0\d+)', r'\1 \2', payload)

    ##########################################
    ##########################################

    print(payload)

    toks = payload.split()
    return _coerce_fields_from_tokens(toks)


def wavelengths_from_multispec_payload(payload: str) -> np.ndarray:
    """Convert a single IRAF multispec payload to a wavelength array.

    Expected strict layout (9 fields after coercion):
        aperture(2d) beam(1) dtype(0) w1(4+12) dw(0+18) nw(4d)
        z(0.000000) pmin(6dp) pmax(6dp)

    Wavelengths (dtype==0, linear) use IRAF's 1-based pixel convention:

        lambda[i] = w1 + (i - 1) * dw,   i = 1..nw

    NumPy equivalent:

        lam = w1 + dw * np.arange(nw)

    Generated by GPT-5 Thinking on October 15 2025.

    Args:
        payload: The content inside a `specN = "..."` block.

    Returns:
        1D numpy array of wavelengths.

    Raises:
        NotImplementedError: If dispersion `dtype` is not linear (0).
        ValueError: If parsing fails.
    """
    f = _payload_fields(payload)

    dtype = int(f[2])
    if dtype != 0:
        raise NotImplementedError(
            f"dtype={dtype} not supported (only linear dtype=0)."
        )

    w1 = float(f[3])
    dw = float(f[4])
    nw = int(f[5])

    lam = w1 + dw * np.arange(nw, dtype=float)
    return lam


def load_multispec_wavelengths(
    filename: str,
) -> Dict[int, np.ndarray]:
    """Load wavelength solutions for all `specN` blocks in a FITS file.

    The file must contain IRAF "multispec" WAT header cards. This
    function parses the linear solutions (dtype=0) and returns a mapping
    from `specN` index (1-based) to wavelength arrays.

    Generated by GPT-5 Thinking on October 15 2025.

    Args:
        filename: Path to the FITS file.

    Returns:
        Dict mapping `spec index` -> wavelength array for that spectrum.

    Raises:
        NotImplementedError: If any `specN` uses a non-linear dtype.
        KeyError: If blocks are missing.
        ValueError: If payloads cannot be coerced to the strict format.
    """
    with fits.open(filename) as hdul:
        hdr = hdul[0].header.copy()

    wat = _concat_wat_strings(hdr, prefixes=("WAT2_",))
    blocks = _parse_spec_blocks(wat)

    wl: Dict[int, np.ndarray] = {}
    for spec_idx, payload in blocks.items():
        wl[spec_idx] = wavelengths_from_multispec_payload(payload)

    if not wl:
        raise KeyError("No multispec `specN` blocks found in WAT headers.")

    return wl


def read_mike(filename: str) -> tuple[np.ndarray, np.ndarray]:
    """Read MIKE-style echelle product and return flux and wavelengths.

    Assumptions:
      * Data are in HDU 0 with shape (7, 35, 4096).
      * Index 6 in the first axis is the object spectrum divided by the
        flat (a relative-fluxed spectrum).
      * Wavelength solutions are via IRAF WAT* "multispec" cards with
        linear dispersion (dtype=0) and strict field formats described
        in `_coerce_fields_from_tokens`.
      * There are 35 orders, each with 4096 pixels.

    Generated by GPT-5 Thinking on October 15 2025.

    Args:
        filename: Path to the FITS file.

    Returns:
        Tuple (flx_2d, wav_2d):
            flx_2d: ndarray with shape (35, 4096), relative flux.
            wav_2d: ndarray with shape (35, 4096), wavelengths (Angstrom).

    Raises:
        ValueError: If on-disk array does not match expected shape.
        KeyError: If WAT multispec entries are missing or incomplete.
        NotImplementedError: If non-linear dispersion is encountered.
    """
    with fits.open(filename) as hdul:
        d = hdul[0].data

    if d is None or d.ndim != 3:
        raise ValueError("Expected data with shape (7, 35, 4096).")

    flx_2d = np.array(d[6, :, :], dtype=float)

    wl_dict = load_multispec_wavelengths(filename)

    n_orders = flx_2d.shape[0]
    n_pix = flx_2d.shape[1]
    wav_2d = np.empty((n_orders, n_pix), dtype=float)

    for order_idx in range(n_orders):
        spec_idx = order_idx + 1
        if spec_idx not in wl_dict:
            raise KeyError(f"Missing wavelength for spec{spec_idx}.")
        lam = wl_dict[spec_idx]
        if lam.size != n_pix:
            raise ValueError(
                f"spec{spec_idx} wavelength length {lam.size} != {n_pix}."
            )
        wav_2d[order_idx, :] = lam

    return flx_2d, wav_2d

